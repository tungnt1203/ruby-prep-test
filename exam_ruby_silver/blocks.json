{
  "topic": "Ruby 3.1.x Silver - Blocks",
  "questions": [
    {
      "id": 1,
      "type": "single",
      "question": "What are the two **syntaxes** for writing a block in Ruby?",
      "options": {"A": "do...end and { }", "B": "block...end and [ ]", "C": "lambda and proc", "D": "function and =>"},
      "answer": "A",
      "explanation": "Blocks are written with do...end (multi-line) or { } (single-line). Both create a block that can be passed to a method."
    },
    {
      "id": 2,
      "type": "single",
      "question": "What is the output?\n\n```ruby\n[1, 2, 3].each do |x|\n  puts x * 2\nend\n```",
      "options": {"A": "2 4 6", "B": "1 2 3", "C": "6", "D": "[2, 4, 6]"},
      "answer": "A",
      "explanation": "each yields each element to the block. The block receives x and prints x*2: 2, 4, 6."
    },
    {
      "id": 3,
      "type": "single",
      "question": "How do you pass **arguments** to a block when using **yield**?",
      "options": {"A": "yield arg1, arg2", "B": "block.call(arg1, arg2)", "C": "pass arg1, arg2", "D": "A and B"},
      "answer": "D",
      "explanation": "yield arg1, arg2 passes arguments to the block. If you captured the block as a Proc with &block, you use block.call(arg1, arg2)."
    },
    {
      "id": 4,
      "type": "single",
      "question": "What does a **block** return?",
      "options": {"A": "The value of the last expression in the block", "B": "nil always", "C": "The receiver", "D": "The block itself"},
      "answer": "A",
      "explanation": "A block, like a method, returns the value of its last expression. The method that yielded can use this return value (e.g. map collects these values)."
    },
    {
      "id": 5,
      "type": "single",
      "question": "What is the output?\n\n```ruby\nresult = [1, 2, 3].map { |n| n * 2 }\nputs result.inspect\n```",
      "options": {"A": "[2, 4, 6]", "B": "[1, 2, 3]", "C": "6", "D": "nil"},
      "answer": "A",
      "explanation": "map yields each element to the block and collects the block's return values. So we get [2, 4, 6]."
    },
    {
      "id": 6,
      "type": "single",
      "question": "Can a block **see and modify** variables from the enclosing scope?",
      "options": {"A": "Yes; blocks close over the surrounding scope", "B": "No; blocks are isolated", "C": "Only read, not modify", "D": "Only with global variables"},
      "answer": "A",
      "explanation": "Blocks are closures: they capture the surrounding scope and can both read and modify variables from that scope."
    },
    {
      "id": 7,
      "type": "single",
      "question": "What is the output?\n\n```ruby\nsum = 0\n[1, 2, 3].each { |n| sum += n }\nputs sum\n```",
      "options": {"A": "6", "B": "0", "C": "3", "D": "[1, 2, 3]"},
      "answer": "A",
      "explanation": "The block closes over sum and adds each element. After the each, sum is 1+2+3 = 6."
    },
    {
      "id": 8,
      "type": "single",
      "question": "How do you convert a **block** into a **Proc** object inside a method?",
      "options": {"A": "Use &block in the parameter list", "B": "Block.new", "C": "Proc.new(block)", "D": "Blocks are already Procs"},
      "answer": "A",
      "explanation": "def foo(&block) captures the passed block as a Proc in the variable block. You can then store it, pass it, or call block.call(args)."
    },
    {
      "id": 9,
      "type": "single",
      "question": "What is the output?\n\n```ruby\ndef run(&blk)\n  blk.call(2)\nend\nrun { |x| puts x + 1 }\n```",
      "options": {"A": "3", "B": "2", "C": "nil", "D": "Error"},
      "answer": "A",
      "explanation": "&blk captures the block as a Proc. blk.call(2) passes 2 to the block; the block computes 2+1 and puts 3."
    },
    {
      "id": 10,
      "type": "single",
      "question": "What does **Symbol#to_proc** (e.g. &:upcase) do?",
      "options": {"A": "Creates a block that sends that method to each element", "B": "Converts symbol to string", "C": "Returns the method object", "D": "Syntax error"},
      "answer": "A",
      "explanation": "&:upcase is shorthand for { |obj| obj.upcase }. It creates a block that calls the named method on its argument. Used with map, select, etc."
    },
    {
      "id": 11,
      "type": "single",
      "question": "What is the output?\n\n```ruby\nputs [\"a\", \"bb\", \"ccc\"].map(&:length).inspect\n```",
      "options": {"A": "[1, 2, 3]", "B": "[\"a\", \"bb\", \"ccc\"]", "C": "6", "D": "Error"},
      "answer": "A",
      "explanation": "&:length is like { |s| s.length }. So we get the length of each string: [1, 2, 3]."
    },
    {
      "id": 12,
      "type": "single",
      "question": "How many **blocks** can you pass to a method in Ruby?",
      "options": {"A": "One", "B": "Unlimited", "C": "Two (do...end and { })", "D": "Zero or one"},
      "answer": "A",
      "explanation": "A method call can receive at most one block. The block is implicit (not a regular argument). To pass more callable objects, use Proc/lambda as normal arguments."
    },
    {
      "id": 13,
      "type": "single",
      "question": "What is the **difference** between **Proc** and **lambda** in Ruby?",
      "options": {"A": "return in lambda returns from the lambda; return in Proc returns from the enclosing method", "B": "They are identical", "C": "Lambda checks argument count; Proc is lenient", "D": "A and C"},
      "answer": "D",
      "explanation": "Lambda: return exits the lambda; strict argument count. Proc: return exits the enclosing method; extra/missing args are tolerated. Both are Proc objects (lambda? tells them apart)."
    },
    {
      "id": 14,
      "type": "single",
      "question": "What is the output?\n\n```ruby\n[1, 2, 3].select { |n| n > 1 }\n```",
      "options": {"A": "[2, 3]", "B": "[1, 2, 3]", "C": "true", "D": "[1]"},
      "answer": "A",
      "explanation": "select keeps elements for which the block returns truthy. n > 1 is true for 2 and 3, so we get [2, 3]."
    },
    {
      "id": 15,
      "type": "single",
      "question": "What does **break** do when used inside a block?",
      "options": {"A": "Exits the block and the method that yielded to it", "B": "Skips to the next iteration", "C": "Returns from the block only", "D": "Raises an error"},
      "answer": "A",
      "explanation": "break in a block terminates the iterator (e.g. each) and can make the iterator return a value: break value. It exits the method that is iterating."
    },
    {
      "id": 16,
      "type": "single",
      "question": "What is the output?\n\n```ruby\nresult = [1, 2, 3, 4].each do |n|\n  break n * 10 if n == 2\nend\nputs result\n```",
      "options": {"A": "20", "B": "[1, 2, 3, 4]", "C": "2", "D": "10"},
      "answer": "A",
      "explanation": "When n is 2, we break with value n*10 = 20. So each returns 20 (the break value), and result is 20."
    },
    {
      "id": 17,
      "type": "single",
      "question": "What does **next** do inside a block?",
      "options": {"A": "Exits the method that yielded", "B": "Skips the rest of the current iteration and continues to the next", "C": "Returns the block value", "D": "Restarts the iteration"},
      "answer": "B",
      "explanation": "next in a block skips the remainder of the current iteration and proceeds to the next element. Optional: next value sets the value for this iteration (e.g. in map)."
    },
    {
      "id": 18,
      "type": "single",
      "question": "What is the output?\n\n```ruby\n[1, 2, 3].each do |x|\n  next if x == 2\n  puts x\nend\n```",
      "options": {"A": "1 then 3", "B": "1 2 3", "C": "2", "D": "1 then 2 then 3"},
      "answer": "A",
      "explanation": "next if x == 2 skips the iteration when x is 2. So we print 1 and 3 only."
    },
    {
      "id": 19,
      "type": "single",
      "question": "Is a **block** an object in Ruby?",
      "options": {"A": "No; it is a syntactic construct, not an object", "B": "Yes; it is a Proc", "C": "Yes; it is a Block class", "D": "Only when captured with &"},
      "answer": "D",
      "explanation": "A block by itself is not an object; you cannot assign it to a variable directly. When you capture it with &block in a method, it is converted to a Proc object."
    },
    {
      "id": 20,
      "type": "single",
      "question": "What is the output?\n\n```ruby\np [1, 2, 3].reduce(0) { |sum, n| sum + n }\n```",
      "options": {"A": "6", "B": "0", "C": "[1, 2, 3]", "D": "Error"},
      "answer": "A",
      "explanation": "reduce(0) starts with initial 0. The block receives (sum, n) and returns sum + n. So we get 0+1=1, 1+2=3, 3+3=6. Result is 6."
    },
    {
      "id": 21,
      "type": "single",
      "question": "What is **block_given?** used for?",
      "options": {"A": "To check if a block was passed to the current method", "B": "To get the block object", "C": "To pass the block to another method", "D": "To define a default block"},
      "answer": "A",
      "explanation": "block_given? (alias iterator?) returns true if the current method was called with a block. Used to make blocks optional and avoid LocalJumpError when calling yield."
    },
    {
      "id": 22,
      "type": "single",
      "question": "What is the output?\n\n```ruby\n3.times { |i| puts i }\n```",
      "options": {"A": "0 1 2", "B": "1 2 3", "C": "3", "D": "0 1 2 3"},
      "answer": "A",
      "explanation": "Integer#times yields 0, 1, 2 to the block. So we print 0, 1, 2."
    },
    {
      "id": 23,
      "type": "single",
      "question": "Can you pass a **block** to **yield** from another method?",
      "options": {"A": "No; yield only invokes the block passed to the current method", "B": "Yes; yield can take a block argument", "C": "Only with block.call", "D": "Only with Proc"},
      "answer": "A",
      "explanation": "yield invokes only the block that was passed to the current method. It does not accept a block as an argument. To pass a block to another method, call that method with a block literal or &proc."
    },
    {
      "id": 24,
      "type": "single",
      "question": "What is the output?\n\n```ruby\narr = [10, 20, 30]\narr.each_with_index { |val, i| puts \"#{i}: #{val}\" }\n```",
      "options": {"A": "0: 10 1: 20 2: 30", "B": "10 20 30", "C": "1: 10 2: 20 3: 30", "D": "Error"},
      "answer": "A",
      "explanation": "each_with_index yields (element, index). So we get (10,0), (20,1), (30,2) and print \"0: 10\", \"1: 20\", \"2: 30\"."
    },
    {
      "id": 25,
      "type": "multiple",
      "question": "Which **Enumerable** methods typically take a block?",
      "options": {"A": "each", "B": "map", "C": "select", "D": "length"},
      "answer": ["A", "B", "C"],
      "explanation": "each, map, select, reduce, find, etc. take a block. length does not take a block (it returns the size)."
    },
    {
      "id": 26,
      "type": "single",
      "question": "What is the output?\n\n```ruby\na = 1\n[2, 3].each { |a| a = 10 }\nputs a\n```",
      "options": {"A": "1", "B": "10", "C": "3", "D": "Error"},
      "answer": "A",
      "explanation": "The block parameter |a| shadows the outer a. Assignments inside the block change the block-local a, not the outer a. So the outer a stays 1."
    },
    {
      "id": 27,
      "type": "single",
      "question": "What is **yield** without arguments?",
      "options": {"A": "Calls the block with no arguments", "B": "Syntax error", "C": "Returns nil", "D": "Same as yield nil"},
      "answer": "A",
      "explanation": "yield with no arguments invokes the block with no arguments. The block can have no parameters: { } or do end."
    },
    {
      "id": 28,
      "type": "single",
      "question": "What is the output?\n\n```ruby\np (1..4).find { |n| n > 2 }\n```",
      "options": {"A": "3", "B": "[3, 4]", "C": "true", "D": "4"},
      "answer": "A",
      "explanation": "find returns the first element for which the block is truthy. First n where n > 2 is 3, so we get 3."
    },
    {
      "id": 29,
      "type": "single",
      "question": "How do you pass a **Proc** as a **block** to a method?",
      "options": {"A": "Use & in the call: method(&my_proc)", "B": "Pass it as the last argument", "C": "Use block(my_proc)", "D": "Procs cannot be passed as blocks"},
      "answer": "A",
      "explanation": "&my_proc in a method call converts the Proc to a block and passes it. So method(&my_proc) is equivalent to method { |*args| my_proc.call(*args) }."
    },
    {
      "id": 30,
      "type": "single",
      "question": "What is the output?\n\n```ruby\nreject_result = [1, 2, 3, 4].reject { |n| n.even? }\nputs reject_result.inspect\n```",
      "options": {"A": "[1, 3]", "B": "[2, 4]", "C": "[1, 2, 3, 4]", "D": "[]"},
      "answer": "A",
      "explanation": "reject keeps elements for which the block returns false. n.even? is false for 1 and 3, so we get [1, 3]."
    },
    {
      "id": 31,
      "type": "single",
      "question": "What is the output?\n\n```ruby\nitem = \"apple\"\n[\"banana\", \"carrot\"].each do |item|\n  puts item\nend\nputs item\n```",
      "options": {"A": "banana carrot apple", "B": "banana carrot carrot", "C": "banana carrot banana", "D": "Syntax error"},
      "answer": "A",
      "explanation": "Block parameter |item| shadows outer item. Inside block, item refers to the iterated value. After the block, outer item is unchanged (still \"apple\")."
    }
  ]
}
